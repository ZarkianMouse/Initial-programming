//    COPYRIGHT (C) Will Crissey, Jr. 2017  All rights reserved.
// This will demonstrate a TEMPLATE FUNCTION
// We are going to create a templated function
// the function will simply compare two items for equality
// it is a predicate function (returns a bool) - true when equal
//
//
// Items can be anything comparable using fundamental types
// we will try ints, chars, and maybe float or double
//
// We're going to use the Complex class we've been using
// we need to overload the equal and stream operators
// (with the operator function)
//
// B/C it's not very big, it will be easier for this demo
// to combine the solution altogether here for readability.

#include <iostream>

// function template - let's call it isEqualTo
// the letter T is fairly common to examples, but could be anything
// meaningful, of course
// Note the keywords typename and class that specify function-template
// parameters actually mean “any fundamental type or user-defined type

// pretty straight-forward - just compare two parameters for equality
template <typename T>
bool isEqualTo(const T& arg1, const T& arg2)
{
   return arg1 == arg2;
}


// class used to demonstrate overloading operators
// this is necessary when using templates.
class Complex
{
   friend std::ostream& operator<<(std::ostream&, Complex&);
public:
   // constructor for Fraction
   Complex(int realPart, int iPart)
      : real(realPart), imaginary(iPart) { }

// recall this is an intialization section with an empty member function

   // Overloaded equality operator. If this is not provided, the
   // program will not compile.
   bool operator==(const Complex& right) const
   {
      return real == right.real && imaginary == right.imaginary;
   }
private:
   int real; // real part of the complex number
   int imaginary; // imaginary part of the complex number
};

// before we continue - a note about the == overloading
/*
overloading some operators is necessary when using templates. Why?
A template that's invoked with a user-defined type using
functions or operators (such as ==, +, <=) with objects
of that class type, those functions and operators must be overloaded
for the user-defined type. If we don't we get compilation errors.
*/

// overloaded << operator
std::ostream& operator<<(std::ostream& out, Complex& obj)
{
   if (obj.imaginary > 0)
   { // positive imaginary
      out << obj.real << " + " << obj.imaginary << "i";
   }
   else if (obj.imaginary == 0)
   { // zero imaginary
      out << obj.real;
   }
   else
   { // negative imaginary
      out << obj.real << " - " << -obj.imaginary << "i";
   }

   return out;
}

int main()
{
   int a; // integers used for
   int b; // testing equality

   // test if two ints input by user are equal
   std::cout << "Enter two integer values: ";
   std::cin >> a >> b;
   std::cout << a << " and " << b << " are "
      << (isEqualTo(a, b) ? "equal" : "not equal") << '\n';
// note - ternary AKA conditional operator
// good for situations where you need to choose two different values
// depending on a single condition, but not a good general-purpose substitute
// for if/else statements…


// let's write some more test cases

   char c; // chars used for
   char d; // testing equality

// repeat the same coding

   // test if two chars input by user are equal
   std::cout << "\nEnter two character values: ";
   std::cin >> c >> d;
   std::cout << c << " and " << d << " are "
      << (isEqualTo(c, d) ? "equal" : "not equal") << '\n';

   double e; // double values used for
   double f; // testing equality

   // test if two doubles input by user are equal
   std::cout << "\nEnter two double values: ";
   std::cin >> e >> f;
   std::cout << e << " and " << f << " are "
      << (isEqualTo(e, f) ? "equal" : "not equal") << '\n';

// now let's test two complex objects!

   Complex g{10, 5}; // Complex objects used
   Complex h{10, 5}; // for testing equality

   // test if two Complex objects are equal
   // uses overloaded << operator
   std::cout << "\nThe class objects " << g << " and " << h << " are "
      << (isEqualTo(g, h) ? "equal" : "not equal") << '\n';
}

/*
Another note -

Although templates offer software-reusability benefits,
remember that multiple function template specializations
and class-template specializations are instantiated in a program
(at compile time), despite the fact that the templates are written
only once. These copies can consume considerable memory.

This is not normally an issue, though, because the code
generated by the template is the same size as the code
you’d have written to produce the separate overloaded functions.
*/
